// type RObject<
//   TObject,
//   TAttr extends RAttributes | undefined = undefined,
//   TJson = void
// > = {
//   type: string;
//   value: TObject;
//   // if TAttr is undefined, then the attributes type is undefined; otherwise, it is { type: "tagged_list", value: TAttr}
//   attributes?: TAttr extends undefined
//     ? undefined
//     : {
//         type: "tagged_list";
//         value: TAttr;
//       };
//   json: (
//     this: RObject<TObject, TAttr, TJson>,
//     resolver?: (value: string) => string
//   ) => TJson;
// };
// type Attrs = {
//   type: string;
//   value: RAttributes;
// };
// type RAttributes = Array<{
//   name: string | null;
//   value: RObject<unknown, any, unknown>;
// }>;

// const make_basic = <TObject>(type: string) => {
//   return <TJson>(
//     json?: (
//       this: RObject<TObject>,
//       resolver?: (value: string) => string
//     ) => TJson
//   ) => {
//     const wrapped_json = function (
//       this: RObject<TObject>,
//       resolver: (value: string) => string
//     ) {
//       if (!json) throw new Error("json() unsupported for type " + this.type);
//       const res = json.call(this, resolver);
//       if (!Array.isArray(res) && !ArrayBuffer.isView(res)) return res;
//       let result = res as TJson & {
//         r_type: string;
//         r_attributes?: {
//           [key: string]: any;
//         };
//       };
//       result.r_type = type;
//       if (this.attributes) {
//         result.r_attributes = Object.fromEntries(
//           this.attributes.value.map((v) => [v.name, v.value.json(resolver)])
//         );
//       }
//       return result;
//     };

//     return function <TAttr extends RAttributes>(
//       value: TObject,
//       attributes?: TAttr
//     ) {
//       function r_object(this: RObject<TObject, TAttr, TJson>) {
//         this.type = type;
//         this.value = value;
//         this.attributes = undefined;
//         if (attributes)
//           this.attributes = { type: "tagged_list", value: attributes };
//       }
//       r_object.prototype = {
//         json: json,
//       };
//       const result = new (r_object as any)() as RObject<TObject, TAttr, TJson>;
//       return result;
//     };
//   };
// };

// const make_string_array = make_basic<string[]>("string_array")(function () {
//   if (this.value.length === 1 && !this.attributes) return this.value[0];
//   return this.value;
// });

// // a number constructor
// const make_number_wrapper = make_basic<number[]>("number");
// const make_number = make_number_wrapper(function (resolver) {
//   if (this.value.length === 1 && !this.attributes) return this.value[0];
//   return this.value;
// });
// const number = make_number(
//   [1, 2, 3]
//   // [
//   //   {
//   //     name: "levels",
//   //     value: make_string_array(["one", "two", "three"]),
//   //   },
//   // ]
// );
// const z = number.attributes;

// // <TJson>(function (this: RObject<TObject, TAttr, TJson>,
// //   resolver?: (value: string) => string
// // ): TJson) => {
// //   return 1;
// // }

// {
//   // const wrapped_json = function (
//   //   this: RObject<TObject, TAttr, TJson>,
//   //   resolver: (value: string) => string
//   // ) {
//   //   if (!json) throw new Error("json() unsupported for type " + this.type);
//   //   const res = json.call(this, resolver);
//   //   if (!Array.isArray(res) && !ArrayBuffer.isView(res)) return res;
//   //   let result = res as TJson & {
//   //     r_type: string;
//   //     r_attributes?: {
//   //       [key: string]: any;
//   //     };
//   //   };
//   //   result.r_type = this.type;
//   //   if (this.attributes) {
//   //     result.r_attributes = Object.fromEntries(
//   //       this.attributes.value.map((v) => [v.name, v.value.json(resolver)])
//   //     );
//   //   }
//   //   return result;
//   // };
//   // return function (value: TObject, attributes?: TAttr) {
//   //   function r_object(this: RObject<TObject, TAttr, TJson>) {
//   //     this.type = type;
//   //     this.value = value;
//   //     if (attributes)
//   //       this.attributes = {
//   //         type: "tagged_list",
//   //         value: attributes,
//   //       };
//   //   }
//   //   r_object.prototype = {
//   //     json: json,
//   //   };
//   //   const result = new (r_object as any)() as RObject<TObject, any, any>;
//   //   return result;
//   // };
// }

// const double_array = make_basic<number[]>("double_array")(function () {
//   if (this.value.length === 1 && !this.attributes) return this.value[0];
//   return this.value;
// });

// const makeNumber = make_basic<number[], undefined, number[]>(
//   "number",
//   (resolver) => this.value
// );
// const x = makeNumber([1, 2, 3]);
// console.log(x.value);
// console.log(x.json());
